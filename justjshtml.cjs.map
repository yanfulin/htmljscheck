{"version":3,"file":"justjshtml.cjs","sources":["../src/errors.js","../src/tokenizer.js","../src/nodes.js","../src/tree-builder.js","../src/index.js"],"sourcesContent":["// src/errors.js\n\n/**\n * @class ParseError\n * @augments Error\n * @description Represents a parsing error encountered by the tokenizer or tree builder.\n */\nexport class ParseError extends Error {\n  /**\n   * @type {number}\n   * @description The line number where the error occurred.\n   */\n  line;\n\n  /**\n   * @type {number}\n   * @description The column number where the error occurred.\n   */\n  column;\n\n  /**\n   * @type {number}\n   * @description The index in the input string where the error occurred.\n   */\n  index;\n\n  /**\n   * Creates an instance of ParseError.\n   * @param {string} message - A human-readable error message.\n   * @param {number} line - The line number where the error occurred.\n   * @param {number} column - The column number where the error occurred.\n   * @param {number} index - The index in the input string where the error occurred.\n   */\n  constructor(message, line, column, index) {\n    super(message);\n    this.line = line;\n    this.column = column;\n    this.index = index;\n  }\n}","// src/tokenizer.js\n\nimport { ParseError } from './errors.js';\n\nconst State = {\n  DATA: 1,\n  TAG_OPEN: 2,\n  TAG_NAME: 3,\n  END_TAG_OPEN: 4,\n  BEFORE_ATTRIBUTE_NAME: 5,\n  ATTRIBUTE_NAME: 6,\n  AFTER_ATTRIBUTE_NAME: 7,\n  BEFORE_ATTRIBUTE_VALUE: 8,\n  ATTRIBUTE_VALUE_DOUBLE_QUOTED: 9,\n  ATTRIBUTE_VALUE_SINGLE_QUOTED: 10,\n  ATTRIBUTE_VALUE_UNQUOTED: 11,\n  COMMENT: 12,\n  MARKUP_DECLARATION_OPEN: 13,\n};\n\nexport class Tokenizer {\n  constructor(options = {}) {\n    this.options = options;\n    this.state = State.DATA;\n    this.buffer = '';\n    this.is_end_tag = false;\n    this.current_token = null;\n    this.line = 1;\n    this.column = 1;\n    this.index = 0;\n    this.errors = [];\n    this.tokens = [];\n    this.html = '';\n    this.current_attribute_name = ''; // To store the attribute name while parsing its value\n    this.current_attribute_value = ''; // To store the attribute value\n  }\n\n  run(html) {\n    this.html = html;\n    for (let i = 0; i < html.length; i++) {\n      const char = html[i];\n      this.consume(char);\n      this.index++;\n      if (char === '\\n') {\n        this.line++;\n        this.column = 1;\n      } else {\n        this.column++;\n      }\n    }\n    return this.tokens;\n  }\n\n  emit(token) {\n    this.tokens.push(token);\n  }\n\n  consume(char) {\n    switch (this.state) {\n      case State.DATA:\n        if (char === '<') {\n          this.state = State.TAG_OPEN;\n        } else {\n          this.emit(['Character', char]);\n        }\n        break;\n      case State.TAG_OPEN:\n        if (char === '!') {\n          this.state = State.MARKUP_DECLARATION_OPEN;\n        } else if (/[a-zA-Z]/.test(char)) {\n          this.current_token = { type: 'start_tag', tag: char.toLowerCase(), attributes: {} };\n          this.state = State.TAG_NAME;\n          this.is_end_tag = false;\n        } else if (char === '/') {\n          this.state = State.END_TAG_OPEN;\n        } else {\n          this.error(\"Unexpected character in tag open state\");\n        }\n        break;\n      case State.END_TAG_OPEN:\n        if (/[a-zA-Z]/.test(char)) {\n          this.current_token = { type: 'end_tag', tag: char.toLowerCase() };\n          this.state = State.TAG_NAME;\n          this.is_end_tag = true;\n        } else {\n          this.error(\"Unexpected character in end tag open state\");\n        }\n        break;\n      case State.TAG_NAME:\n        if (char === '>') {\n          this.emit_current_token();\n          this.state = State.DATA;\n        } else if (/\\s/.test(char)) {\n          this.state = State.BEFORE_ATTRIBUTE_NAME;\n        } else if (/[a-zA-Z]/.test(char)) {\n          this.current_token.tag += char.toLowerCase();\n        } else {\n          this.error(\"Unexpected character in tag name state\");\n        }\n        break;\n      case State.BEFORE_ATTRIBUTE_NAME:\n        if (/\\s/.test(char)) {\n          // ignore\n        } else if (/[a-zA-Z]/.test(char)) {\n          this.current_attribute_name = char.toLowerCase(); // Start collecting attribute name\n          this.current_attribute_value = '';\n          this.state = State.ATTRIBUTE_NAME;\n        } else if (char === '>') {\n          this.emit_current_token();\n          this.state = State.DATA;\n        } else {\n          this.error(\"Unexpected character in before attribute name state\");\n        }\n        break;\n      case State.ATTRIBUTE_NAME:\n        if (char === '=') {\n          this.state = State.BEFORE_ATTRIBUTE_VALUE;\n        } else if (/\\s/.test(char) || char === '>') { // Attribute name ends with space or >\n          this.current_token.attributes[this.current_attribute_name] = ''; // Attribute with no value\n          this.current_attribute_name = '';\n          this.current_attribute_value = '';\n          this.state = State.BEFORE_ATTRIBUTE_NAME;\n          this.consume(char); // Re-consume the char for correct state handling\n        } else if (/[a-zA-Z]/.test(char)) {\n          this.current_attribute_name += char.toLowerCase();\n        } else {\n          this.error(\"Unexpected character in attribute name state\");\n        }\n        break;\n      case State.BEFORE_ATTRIBUTE_VALUE:\n        if (/\\s/.test(char)) {\n          // ignore\n        } else if (char === '\"') {\n          this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;\n        } else if (char === \"'\") {\n          this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;\n        } else if (/[^\\s>]/.test(char)) { // Unquoted attribute value can't contain space or >\n          this.current_attribute_value += char;\n          this.state = State.ATTRIBUTE_VALUE_UNQUOTED;\n        } else {\n          this.error(\"Unexpected character in before attribute value state\");\n        }\n        break;\n      case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED:\n        if (char === '\"') {\n          this.current_token.attributes[this.current_attribute_name] = this.current_attribute_value;\n          this.current_attribute_name = ''; // Clear current attribute name\n          this.current_attribute_value = ''; // Clear current attribute value\n          this.state = State.BEFORE_ATTRIBUTE_NAME;\n        } else {\n          this.current_attribute_value += char;\n        }\n        break;\n      case State.ATTRIBUTE_VALUE_SINGLE_QUOTED:\n        if (char === \"'\") {\n          this.current_token.attributes[this.current_attribute_name] = this.current_attribute_value;\n          this.current_attribute_name = ''; // Clear current attribute name\n          this.current_attribute_value = ''; // Clear current attribute value\n          this.state = State.BEFORE_ATTRIBUTE_NAME;\n        } else {\n          this.current_attribute_value += char;\n        }\n        break;\n      case State.ATTRIBUTE_VALUE_UNQUOTED:\n        if (/\\s/.test(char) || char === '>') {\n          this.current_token.attributes[this.current_attribute_name] = this.current_attribute_value;\n          this.current_attribute_name = ''; // Clear current attribute name\n          this.current_attribute_value = ''; // Clear current attribute value\n          this.state = State.BEFORE_ATTRIBUTE_NAME;\n          this.consume(char); // Re-consume the char for correct state handling\n        } else {\n          this.current_attribute_value += char;\n        }\n        break;\n      case State.MARKUP_DECLARATION_OPEN:\n          this.buffer += char;\n          if (this.buffer === '--') { // Check for '!--'\n              this.state = State.COMMENT;\n              this.buffer = ''; // Clear buffer for comment content\n          } else {\n              this.error(\"Unexpected character in markup declaration open state\");\n          }\n          break;\n      case State.COMMENT:\n        this.buffer += char;\n        if (this.buffer.endsWith('-->')) {\n          this.emit(['Comment', this.buffer.slice(0, -3)]);\n          this.buffer = '';\n          this.state = State.DATA;\n        }\n        break;\n      default:\n        this.error(\"Unknown state\");\n        break;\n    }\n  }\n\n  emit_current_token() {\n    if(!this.current_token) return;\n    if (this.current_token.type === 'start_tag') {\n      this.emit(['StartTag', this.current_token.tag, this.current_token.attributes]);\n    } else {\n      this.emit(['EndTag', this.current_token.tag]);\n    }\n    this.current_token = null;\n  }\n\n  error(message) {\n    const error = new ParseError(message, this.line, this.column, this.index);\n    if (this.options.strict) {\n      throw error;\n    }\n    if (this.options.collectErrors) {\n      this.errors.push(error);\n    }\n  }\n}","// src/nodes.js\n\n/**\n * @class Node\n * @description Base class for all nodes in the DOM tree.\n */\nexport class Node {\n  /**\n   * @type {string}\n   * @description The type of the node (e.g., 'document', 'element', 'text', 'comment', 'doctype').\n   */\n  type;\n\n  /**\n   * @type {Node|null}\n   * @description The parent node of the current node, or `null` if the node has no parent.\n   */\n  parent;\n\n  /**\n   * @type {Array<Node>}\n   * @description An array of child nodes.\n   */\n  children;\n\n  /**\n   * @type {number}\n   * @description The starting index of the node in the original HTML string.\n   */\n  startIndex;\n\n  /**\n   * @type {number}\n   * @description The ending index of the node in the original HTML string.\n   */\n  endIndex;\n\n  /**\n   * Creates an instance of Node.\n   * @param {string} type - The type of the node.\n   */\n  constructor(type) {\n    this.type = type;\n    this.parent = null;\n    this.children = [];\n    this.startIndex = -1;\n    this.endIndex = -1;\n  }\n\n  /**\n   * Serializes the node and its children to an HTML string.\n   * @param {object} [options={}] - Serialization options.\n   * @param {boolean} [options.pretty=true] - Whether to pretty-print the HTML.\n   * @param {number} [options.indentSize=2] - The number of spaces to use for each level of indentation.\n   * @returns {string} The HTML string representation of the node.\n   */\n  toHTML(options = { pretty: true, indentSize: 2 }, indentLevel = 0) {\n    return this.children.map(child => child.toHTML(options, indentLevel)).join('');\n  }\n\n  /**\n   * Returns the concatenated text content of the node and its children.\n   * @param {object} [options={}] - Options for text serialization.\n   * @param {string} [options.separator=' '] - The separator to use between text content of children.\n   * @returns {string} The text content of the node.\n   */\n  toText(options = { separator: ' ' }) {\n    return this.children.map(child => child.toText(options)).join('');\n  }\n\n  /**\n   * Queries the node and its children using a CSS selector.\n   * @param {string} selector - The CSS selector to use.\n   * @returns {Array<ElementNode>} An array of matching ElementNodes.\n   */\n        query(selector) {\n          const allResults = new Set();\n          const individualSelectors = selector.split(',').map(s => s.trim()).filter(Boolean);\n      \n          for (const individualSelector of individualSelectors) {\n            // Example: \"div > p.intro\" -> [ { type: 'selector', value: 'div' }, { type: 'combinator', value: '>' }, { type: 'selector', value: 'p.intro' } ]\n            const parsedSelectorParts = [];\n            // This regex splits by '>', ' ' while keeping the delimiters and also handles multiple spaces\n            const parts = individualSelector.split(/(\\s*>\\s*|\\s+)/).map(s => s.trim()).filter(Boolean);\n      \n            for (let i = 0; i < parts.length; i++) {\n              const part = parts[i];\n              if (part === '>') {\n                parsedSelectorParts.push({ type: 'combinator', value: '>' });\n              } else if (part === '') { // This can happen with multiple spaces or leading/trailing spaces\n                  continue; // Skip empty parts\n              }\n               else if (i > 0 && parsedSelectorParts[parsedSelectorParts.length - 1].type === 'selector' && part !== '>') {\n                // If the previous was a selector and current is not '>' and not a combinator, it's an implicit descendant\n                parsedSelectorParts.push({ type: 'combinator', value: ' ' });\n                parsedSelectorParts.push({ type: 'selector', value: part });\n              }\n              else {\n                parsedSelectorParts.push({ type: 'selector', value: part });\n              }\n            }\n      \n            Node._findAllMatches(this, parsedSelectorParts, 0, [], allResults);\n          }\n          return Array.from(allResults);\n        }\n      \n        /**\n         * Recursive helper to find all nodes matching a parsed selector.\n         * @param {Node} currentNode - The current node to start searching from.\n         * @param {Array<object>} selectorParts - The parsed selector parts.\n         * @param {number} partIndex - The current index in selectorParts to match.\n         * @param {Array<ElementNode>} currentMatchChain - Nodes that have matched so far in the current path.\n         * @param {Set<ElementNode>} resultsSet - The set to accumulate unique matching ElementNodes.\n         */\n        static _findAllMatches(currentNode, selectorParts, partIndex, currentMatchChain, resultsSet) {\n          if (!currentNode || partIndex >= selectorParts.length) {\n            return;\n          }\n      \n          const currentSelectorPart = selectorParts[partIndex];\n      \n          if (currentSelectorPart.type === 'combinator') {\n              // Combinator at the start of a selector should be handled by the initial call to _findAllMatches\n              // or by a previous selector part that leads to descendants.\n              // If we arrive here, it means we are trying to process a combinator.\n              // We should move to the next selector part.\n              if (currentMatchChain.length === 0) {\n                  // This case implies a malformed selector or an initial call on a combinator, skip it.\n                  Node._findAllMatches(currentNode, selectorParts, partIndex + 1, currentMatchChain, resultsSet);\n                  return;\n              }\n      \n              const prevMatchedNode = currentMatchChain[currentMatchChain.length - 1];\n              if (!prevMatchedNode) return; // Should not happen\n      \n              if (currentSelectorPart.value === '>') { // Direct child combinator\n                  for (const child of prevMatchedNode.children) {\n                      if (child instanceof ElementNode) {\n                          Node._findAllMatches(child, selectorParts, partIndex + 1, [...currentMatchChain, child], resultsSet);\n                      }\n                  }\n              } else if (currentSelectorPart.value === ' ') { // Descendant combinator\n                  // For descendant, we need to check all descendants of the prevMatchedNode\n                  Node._findDescendantsAndMatch(prevMatchedNode, selectorParts, partIndex + 1, currentMatchChain, resultsSet);\n              }\n              return; // Combinator processed\n          }\n      \n          // Attempt to match the current node with the current selector part (if it's a 'selector' type part)\n          if (currentNode instanceof ElementNode && currentSelectorPart.type === 'selector' && Node._matchNode(currentNode, currentSelectorPart.value)) {\n              const newMatchChain = [...currentMatchChain, currentNode];\n      \n              if (partIndex === selectorParts.length - 1) { // This is the last selector part and it matches\n                  resultsSet.add(currentNode);\n              } else {\n                  // It matches, but there are more parts. Move to the next.\n                  Node._findAllMatches(currentNode, selectorParts, partIndex + 1, newMatchChain, resultsSet);\n              }\n          }\n      \n          // Always continue searching in children for the *current* selector part or the next.\n          // This is crucial for descendant behavior or to find the initial match.\n          for (const child of currentNode.children) {\n            if (child instanceof ElementNode || child instanceof DocumentNode) {\n              // If the current part is a selector AND we are at the beginning of the search for this part,\n              // OR if the previous part was a descendant combinator,\n              // we try to match the current selector part on the child.\n              if (currentSelectorPart.type === 'selector' && (partIndex === 0 || (partIndex > 0 && selectorParts[partIndex - 1].value === ' '))) {\n                  Node._findAllMatches(child, selectorParts, partIndex, currentMatchChain, resultsSet);\n              }\n            }\n          }\n        }\n      \n        /**\n         * Helper for descendant combinator: finds all descendants from startNode and tries to match.\n         * This is called when a ' ' combinator is encountered.\n         * @param {Node} startNode - The node from which to find descendants.\n         * @param {Array<object>} selectorParts - The parsed selector parts.\n         * @param {number} partIndex - The current index in selectorParts to match.\n         * @param {Array<ElementNode>} currentMatchChain - Nodes that have matched so far.\n         * @param {Set<ElementNode>} resultsSet - The set to accumulate unique matching ElementNodes.\n         */\n        static _findDescendantsAndMatch(startNode, selectorParts, partIndex, currentMatchChain, resultsSet) {\n          if (!startNode) {\n            return;\n          }\n          for (const child of startNode.children) {\n              if (child instanceof ElementNode || child instanceof DocumentNode) {\n                  // Try to match the next selector part directly on the child\n                  Node._findAllMatches(child, selectorParts, partIndex, [...currentMatchChain, child], resultsSet);\n                  // Also recursively search descendants of the child\n                  Node._findDescendantsAndMatch(child, selectorParts, partIndex, currentMatchChain, resultsSet);\n              }\n          }\n        }\n          /**\n     * Helper method to check if an ElementNode matches a single simple selector part.\n     * @param {ElementNode} node - The element node to check.\n     * @param {string} simpleSelectorPart - The simple selector string (e.g., 'div', '#id', '.class').\n     * @returns {boolean} - True if the node matches the simple selector, false otherwise.\n     */\n      _matchesSimpleSelector(node, simpleSelectorPart) {\n        if (!(node instanceof ElementNode)) {\n            return false;\n        }\n    \n        if (simpleSelectorPart.startsWith('#')) { // ID selector\n            return node.attributes.id === simpleSelectorPart.substring(1);\n        } else if (simpleSelectorPart.startsWith('.')) { // Class selector\n            return node.attributes.class && node.attributes.class.split(' ').includes(simpleSelectorPart.substring(1));\n        } else { // Tag name selector\n            return node.tag === simpleSelectorPart;\n        }\n      }\n    \n      /**\n       * Helper method to check if an ElementNode matches a complex selector part\n       * (e.g., 'div#id.class').\n       * @param {ElementNode} node - The element node to check.\n       * @param {string} selectorPart - The complex selector part string.\n       * @returns {boolean} - True if the node matches, false otherwise.\n       */\n      static _matchNode(node, selectorPart) {\n        if (!(node instanceof ElementNode)) {\n          return false;\n        }\n    \n        // Regex to extract tag, id, and classes\n        const match = selectorPart.match(/^(?:(\\w+))?(?:#([\\w-]+))?(?:\\.([\\w.-]+))?$/);\n        if (!match) {\n          return false; // Malformed selector part\n        }\n    \n        const [, tag, id, classes] = match;\n    \n        if (tag && node.tag.toLowerCase() !== tag.toLowerCase()) { // Case-insensitive tag matching\n          return false;\n        }\n        if (id && node.attributes.id !== id) {\n          return false;\n        }\n        if (classes) {\n          const nodeClasses = node.attributes.class ? node.attributes.class.split(' ') : [];\n          const requiredClasses = classes.split('.');\n          for (const cls of requiredClasses) {\n            if (!nodeClasses.includes(cls)) {\n              return false;\n            }\n          }\n        }\n        return true;\n      }\n\n  /**\n   * Recursive helper to find all nodes matching a parsed selector.\n   * @param {Node} startNode - The current node to start searching from.\n   * @param {Array<object>} selectorParts - The parsed selector parts.\n   * @param {number} partIndex - The current index in selectorParts to match.\n   * @param {Set<ElementNode>} resultsSet - The set to accumulate unique matching ElementNodes.\n   */\n  static _findAllMatches(startNode, selectorParts, partIndex, resultsSet) {\n    if (!startNode || partIndex >= selectorParts.length) {\n      return;\n    }\n\n    const currentSelectorPart = selectorParts[partIndex];\n\n    // If the current part is a combinator, it means the previous selector part has been matched\n    // and we need to determine the search scope for the *next* selector part.\n    if (currentSelectorPart.type === 'combinator') {\n        const combinator = currentSelectorPart.value;\n        const nextSelectorPartIndex = partIndex + 1;\n\n        if (combinator === '>') { // Direct child combinator\n            for (const child of startNode.children) {\n                if (child instanceof ElementNode) {\n                    Node._findAllMatches(child, selectorParts, nextSelectorPartIndex, resultsSet);\n                }\n            }\n        } else if (combinator === ' ') { // Descendant combinator\n            Node._findDescendantsAndMatch(startNode, selectorParts, nextSelectorPartIndex, resultsSet);\n        }\n        return; // Combinator processed, move to next\n    }\n\n    // Attempt to match the current node with the current selector part (if it's a 'selector' type part)\n    if (startNode instanceof ElementNode && Node._matchNode(startNode, currentSelectorPart.value)) {\n        if (partIndex === selectorParts.length - 1) { // It's the last selector part and it matches\n            resultsSet.add(startNode);\n        } else {\n            // It matches, but there are more parts (possibly a combinator next)\n            // Continue search from children of the current matching node, looking for the next part\n            for (const child of startNode.children) {\n                 Node._findAllMatches(child, selectorParts, partIndex + 1, resultsSet);\n            }\n        }\n    }\n\n    // Always continue searching in children for the *current* selector part (descendant behavior).\n    // This is for finding the initial match of a selector or for implicit descendant combinators.\n    // If the current part is a selector, we need to apply it to all descendants unless a combinator\n    // explicitly limits the scope.\n    if (currentSelectorPart.type === 'selector') {\n        for (const child of startNode.children) {\n            // Only if it's the beginning of the search, or if the previous combinator was ' '\n            // This is the core of how descendant selectors work.\n            // We pass the same partIndex, meaning we're still trying to match this selector part.\n            // We need to avoid infinite loops if 'startNode' is DocumentNode and it's trying to match 'html'\n            if (startNode === child.parent) { // Only traverse direct children\n                Node._findAllMatches(child, selectorParts, partIndex, resultsSet);\n            }\n        }\n    }\n  }\n\n  /**\n   * Helper for descendant combinator: finds all descendants from startNode and tries to match.\n   * This is called when a ' ' combinator is encountered.\n   * @param {Node} startNode - The node from which to find descendants.\n   * @param {Array<object>} selectorParts - The parsed selector parts.\n   * @param {number} partIndex - The current index in selectorParts to match.\n   * @param {Set<ElementNode>} resultsSet - The set to accumulate unique matching ElementNodes.\n   */\n  static _findDescendantsAndMatch(startNode, selectorParts, partIndex, resultsSet) {\n    if (!startNode) {\n      return;\n    }\n    for (const child of startNode.children) {\n        if (child instanceof ElementNode || child instanceof DocumentNode) {\n            // Try to match the next selector part on the current child\n            Node._findAllMatches(child, selectorParts, partIndex, resultsSet);\n            // Also recursively search descendants of the child for the same selector part\n            Node._findDescendantsAndMatch(child, selectorParts, partIndex, resultsSet);\n        }\n    }\n  }\n    \n  }\n\n/**\n * @class DocumentNode\n * @augments Node\n * @description Represents the root of the DOM document.\n */\nexport class DocumentNode extends Node {\n  constructor() {\n    super('document');\n  }\n\n  /**\n   * Serializes the document and its children to an HTML string.\n   * @param {object} [options={}] - Serialization options.\n   * @param {boolean} [options.pretty=true] - Whether to pretty-print the HTML.\n   * @param {number} [options.indentSize=2] - The number of spaces to use for each level of indentation.\n   * @returns {string} The HTML string representation of the document.\n   */\n  toHTML(options = { pretty: true, indentSize: 2 }, indentLevel = 0) {\n    let htmlString = '';\n    for (const child of this.children) {\n      const childHtml = child.toHTML(options, indentLevel);\n      if (child.type === 'doctype' && options.pretty && childHtml) {\n        htmlString += childHtml + '\\n';\n      } else {\n        htmlString += childHtml;\n      }\n    }\n    return htmlString;\n  }\n\n  /**\n   * Returns the concatenated text content of the document.\n   * @param {object} [options={}] - Options for text serialization.\n   * @param {string} [options.separator=' '] - The separator to use between text content of children.\n   * @returns {string} The text content of the document.\n   */\n  toText(options = { separator: ' ' }) {\n    const textContent = this.children\n      .map(child => child.toText(options))\n      .filter(Boolean) // Filter out empty strings\n      .join(options.separator);\n    return textContent.replace(/\\s+/g, ' ').trim();\n  }\n}\n\n/**\n * @class ElementNode\n * @augments Node\n * @description Represents an HTML element.\n */\nexport class ElementNode extends Node {\n  /**\n   * @type {string}\n   * @description The tag name of the element (e.g., 'div', 'p').\n   */\n  tag;\n\n  /**\n   * @type {object}\n   * @description An object where keys are attribute names and values are attribute values.\n   */\n  attributes;\n\n  /**\n   * @type {string}\n   * @description The namespace URI of the element.\n   */\n  namespace;\n\n  /**\n   * Creates an instance of ElementNode.\n   * @param {string} tag - The tag name of the element.\n   * @param {string} [namespace='http://www.w3.org/1999/xhtml'] - The namespace URI.\n   */\n  constructor(tag, namespace = 'http://www.w3.org/1999/xhtml') {\n    super('element');\n    this.tag = tag;\n    this.attributes = {};\n    this.namespace = namespace;\n  }\n\n  /**\n   * Serializes the element and its children to an HTML string.\n   * @param {object} [options={}] - Serialization options.\n   * @param {boolean} [options.pretty=true] - Whether to pretty-print the HTML.\n   * @param {number} [options.indentSize=2] - The number of spaces to use for each level of indentation.\n   * @returns {string} The HTML string representation of the element.\n   */\n  toHTML(options = { pretty: true, indentSize: 2 }, indentLevel = 0) {\n    const indent = options.pretty ? ' '.repeat(indentLevel * options.indentSize) : '';\n    const newline = options.pretty ? '\\n' : '';\n\n    const attrs = Object.entries(this.attributes)\n      .map(([key, value]) => `${key}=\"${value}\"`)\n      .join(' ');\n    const tagAttrs = attrs ? ` ${attrs}` : '';\n\n    let childrenHTML = this.children\n      .map(child => child.toHTML(options, indentLevel + 1))\n      .join('');\n\n    // If childrenHTML is not empty and pretty printing is enabled, add newlines and indentation around it\n    if (options.pretty && this.children.length > 0) {\n        // Only add a newline before the first child's content if there are children,\n        // and a newline before the closing tag if there are children.\n        childrenHTML = newline + childrenHTML + newline + indent;\n    }\n\n    if (this.children.length > 0) {\n        return `${indent}<${this.tag}${tagAttrs}>${childrenHTML}</${this.tag}>`;\n    } else {\n        // Empty elements without children, e.g., <div></div> or <br/> (though <br> is typically self-closing)\n        return `${indent}<${this.tag}${tagAttrs}></${this.tag}>`;\n    }\n  }\n\n  /**\n   * Returns the concatenated text content of the element and its children.\n   * @param {object} [options={}] - Options for text serialization.\n   * @param {string} [options.separator=' '] - The separator to use between text content of children.\n   * @returns {string} The text content of the element.\n   */\n  toText(options = { separator: ' ' }) {\n    return this.children.map(child => child.toText(options)).join('');\n  }\n\n  }\n\n/**\n * @class TextNode\n * @augments Node\n * @description Represents a text node.\n */\nexport class TextNode extends Node {\n  /**\n   * @type {string}\n   * @description The text content of the node.\n   */\n  text;\n\n  /**\n   * Creates an instance of TextNode.\n   * @param {string} text - The text content.\n   */\n  constructor(text) {\n    super('text');\n    this.text = text;\n  }\n\n  /**\n   * Serializes the text node to an HTML string.\n   * @returns {string} The HTML string representation of the text node.\n   */\n  toHTML(options) {\n    return this.text;\n  }\n\n  /**\n   * Returns the text content of the node.\n   * @returns {string} The text content.\n   */\n  toText(options) {\n    return this.text;\n  }\n\n  /**\n   * Text nodes do not match any selectors.\n   * @returns {Array<ElementNode>} An empty array.\n   */\n  query(selector) {\n    return [];\n  }\n}\n\n/**\n * @class CommentNode\n * @augments Node\n * @description Represents an HTML comment.\n */\nexport class CommentNode extends Node {\n  /**\n   * @type {string}\n   * @description The text of the comment.\n   */\n  text;\n\n  /**\n   * Creates an instance of CommentNode.\n   * @param {string} text - The comment text.\n   */\n  constructor(text) {\n    super('comment');\n    this.text = text;\n  }\n\n  /**\n   * Serializes the comment node to an HTML string.\n   * @returns {string} The HTML string representation of the comment node.\n   */\n  toHTML(options) {\n    return `<!--${this.text}-->`;\n  }\n\n  /**\n   * Comment nodes do not contribute to the text content.\n   * @returns {string} An empty string.\n   */\n  toText(options) {\n    return '';\n  }\n\n  /**\n   * Comment nodes do not match any selectors.\n   * @returns {Array<ElementNode>} An empty array.\n   */\n  query(selector) {\n    return [];\n  }\n}\n\n/**\n * @class DoctypeNode\n * @augments Node\n * @description Represents an HTML doctype declaration.\n */\nexport class DoctypeNode extends Node {\n  /**\n   * @type {string}\n   * @description The name of the doctype.\n   */\n  name;\n\n  /**\n   * @type {string|null}\n   * @description The public identifier of the doctype.\n   */\n  publicId;\n\n  /**\n   * @type {string|null}\n   * @description The system identifier of the doctype.\n   */\n  systemId;\n\n  /**\n   * Creates an instance of DoctypeNode.\n   * @param {string} name - The name of the doctype.\n   * @param {string|null} publicId - The public identifier.\n   * @param {string|null} systemId - The system identifier.\n   */\n  constructor(name, publicId, systemId) {\n    super('doctype');\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  /**\n   * Serializes the doctype node to an HTML string.\n   * @returns {string} The HTML string representation of the doctype node.\n   */\n  toHTML(options) {\n    if (this.publicId) {\n      return `<!DOCTYPE ${this.name} PUBLIC \"${this.publicId}\" \"${this.systemId}\">`;\n    }\n    if (this.systemId) {\n      return `<!DOCTYPE ${this.name} SYSTEM \"${this.systemId}\">`;\n    }\n    return `<!DOCTYPE ${this.name}>`;\n  }\n\n  /**\n   * Doctype nodes do not contribute to the text content.\n   * @returns {string} An empty string.\n   */\n  toText(options) {\n    return '';\n  }\n\n  /**\n   * Doctype nodes do not match any selectors.\n   * @returns {Array<ElementNode>} An empty array.\n   */\n  query(selector) {\n    return [];\n  }\n}\n","// src/tree-builder.js\nimport { DocumentNode, ElementNode, TextNode, CommentNode } from './nodes.js';\n\n/**\n * @class TreeBuilder\n * @description Constructs a DOM tree from a sequence of tokens.\n */\nexport class TreeBuilder {\n  /**\n   * @type {DocumentNode}\n   * @description The root DocumentNode of the constructed DOM tree.\n   */\n  document;\n\n  /**\n   * @private\n   * @type {Array<import('./nodes.js').Node>}\n   * @description A stack of open nodes, used to maintain the hierarchy of the DOM tree.\n   */\n  stack;\n\n  /**\n   * Creates an instance of TreeBuilder.\n   */\n  constructor() {\n    this.document = new DocumentNode();\n    this.stack = [this.document];\n  }\n\n  /**\n   * Gets the current node on top of the stack.\n   * @returns {import('./nodes.js').Node} The current active node.\n   */\n  get current_node() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  /**\n   * Processes a sequence of tokens to build the DOM tree.\n   * @param {Array<Array<any>>} tokens - The array of tokens generated by the Tokenizer.\n   */\n  run(tokens) {\n    for (const token of tokens) {\n      this.process_token(token);\n    }\n  }\n\n  /**\n   * Processes a single token and updates the DOM tree.\n   * @param {Array<any>} token - The token to process.\n   */\n  process_token(token) {\n    const type = token[0];\n    if (type === 'Character') {\n      this.process_char(token[1]);\n    } else if (type === 'StartTag') {\n      this.start_tag(token);\n    } else if (type === 'EndTag') {\n      this.end_tag(token);\n    } else if (type === 'Comment') {\n      this.comment(token);\n    }\n  }\n\n  /**\n   * Processes a character token, adding it as a TextNode to the current node.\n   * @param {string} char - The character to process.\n   */\n  process_char(char) {\n    const parent = this.current_node;\n    if (parent.children.length > 0 && parent.children[parent.children.length - 1].type === 'text') {\n      parent.children[parent.children.length - 1].text += char;\n    } else {\n      const text_node = new TextNode(char);\n      parent.children.push(text_node);\n      text_node.parent = parent;\n    }\n  }\n\n  /**\n   * Processes a start tag token, creating an ElementNode and pushing it onto the stack.\n   * @param {Array<any>} token - The start tag token.\n   */\n  start_tag(token) {\n    const parent = this.current_node;\n    const element = new ElementNode(token[1]);\n    element.attributes = token[2];\n    parent.children.push(element);\n    element.parent = parent;\n    if (token[1] !== 'br') { // Special handling for self-closing 'br' for now\n        this.stack.push(element);\n    }\n  }\n\n  /**\n   * Processes an end tag token, popping the corresponding node from the stack.\n   * @param {Array<any>} token - The end tag token.\n   */\n  end_tag(token) {\n    const current_node = this.current_node;\n    if (current_node.tag === token[1]) {\n      this.stack.pop();\n    } else {\n      // handle mismatch later\n    }\n  }\n\n  /**\n   * Processes a comment token, creating a CommentNode and adding it to the current node.\n   * @param {Array<any>} token - The comment token.\n   */\n  comment(token) {\n    const parent = this.current_node;\n    const comment = new CommentNode(token[1]);\n    parent.children.push(comment);\n    comment.parent = parent;\n  }\n}","// src/index.js\n\nimport { Tokenizer } from './tokenizer.js';\nimport { TreeBuilder } from './tree-builder.js';\n\n/**\n * Parses an HTML string and returns a document object.\n *\n * @param {string} html The HTML string to parse.\n * @param {object} [options={}] Parsing options.\n * @param {boolean} [options.collectErrors=false] Whether to collect parsing errors.\n * @param {object} [options.fragmentContext=null] The context for parsing an HTML fragment.\n * @param {boolean} [options.strict=false] If `true`, the parser will throw an exception on the first parsing error.\n * @returns {{root: import('./nodes.js').DocumentNode, errors: import('./errors.js').ParseError[], toHTML: function, toText: function, query: function}} The parsed document.\n */\nexport function parseHTML(html, options = {}) {\n  const tokenizer = new Tokenizer(options);\n  const tokens = tokenizer.run(html);\n\n  const treeBuilder = new TreeBuilder();\n  treeBuilder.run(tokens);\n\n  return {\n    root: treeBuilder.document,\n    errors: tokenizer.errors,\n    toHTML: (options) => treeBuilder.document.toHTML(options),\n    toText: (options) => treeBuilder.document.toText(options),\n    query: (selector) => treeBuilder.document.query(selector),\n  };\n}\n"],"names":[],"mappings":"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"}