// src/tree-builder.js
import { DocumentNode, ElementNode, TextNode, CommentNode } from './nodes.js';

/**
 * @class TreeBuilder
 * @description Constructs a DOM tree from a sequence of tokens.
 */
export class TreeBuilder {
  /**
   * @type {DocumentNode}
   * @description The root DocumentNode of the constructed DOM tree.
   */
  document;

  /**
   * @private
   * @type {Array<import('./nodes.js').Node>}
   * @description A stack of open nodes, used to maintain the hierarchy of the DOM tree.
   */
  stack;

  /**
   * Creates an instance of TreeBuilder.
   */
  constructor() {
    this.document = new DocumentNode();
    this.stack = [this.document];
  }

  /**
   * Gets the current node on top of the stack.
   * @returns {import('./nodes.js').Node} The current active node.
   */
  get current_node() {
    return this.stack[this.stack.length - 1];
  }

  /**
   * Processes a sequence of tokens to build the DOM tree.
   * @param {Array<Array<any>>} tokens - The array of tokens generated by the Tokenizer.
   */
  run(tokens) {
    for (const token of tokens) {
      this.process_token(token);
    }
  }

  /**
   * Processes a single token and updates the DOM tree.
   * @param {Array<any>} token - The token to process.
   */
  process_token(token) {
    const type = token[0];
    if (type === 'Character') {
      this.process_char(token[1]);
    } else if (type === 'StartTag') {
      this.start_tag(token);
    } else if (type === 'EndTag') {
      this.end_tag(token);
    } else if (type === 'Comment') {
      this.comment(token);
    }
  }

  /**
   * Processes a character token, adding it as a TextNode to the current node.
   * @param {string} char - The character to process.
   */
  process_char(char) {
    const parent = this.current_node;
    if (parent.children.length > 0 && parent.children[parent.children.length - 1].type === 'text') {
      parent.children[parent.children.length - 1].text += char;
    } else {
      const text_node = new TextNode(char);
      parent.children.push(text_node);
      text_node.parent = parent;
    }
  }

  /**
   * Processes a start tag token, creating an ElementNode and pushing it onto the stack.
   * @param {Array<any>} token - The start tag token.
   */
  start_tag(token) {
    const parent = this.current_node;
    const element = new ElementNode(token[1]);
    element.attributes = token[2];
    parent.children.push(element);
    element.parent = parent;
    if (token[1] !== 'br') { // Special handling for self-closing 'br' for now
        this.stack.push(element);
    }
  }

  /**
   * Processes an end tag token, popping the corresponding node from the stack.
   * @param {Array<any>} token - The end tag token.
   */
  end_tag(token) {
    const current_node = this.current_node;
    if (current_node.tag === token[1]) {
      this.stack.pop();
    } else {
      // handle mismatch later
    }
  }

  /**
   * Processes a comment token, creating a CommentNode and adding it to the current node.
   * @param {Array<any>} token - The comment token.
   */
  comment(token) {
    const parent = this.current_node;
    const comment = new CommentNode(token[1]);
    parent.children.push(comment);
    comment.parent = parent;
  }
}